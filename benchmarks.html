<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>benchmarks</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">faster-multimethods</span> <span class="project-version">0.0.7</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="overview.html"><div class="inner"><span>overview</span></div></a></li><li class="depth-1  current"><a href="benchmarks.html"><div class="inner"><span>benchmarks</span></div></a></li><li class="depth-1 "><a href="changes.html"><div class="inner"><span>change history</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="palisades.lakes.multimethods.core.html"><div class="inner"><span>palisades.lakes.multimethods.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#benchmarks" name="benchmarks"></a>benchmarks</h1>
<p>See <a href="https://github.com/palisades-lakes/multimethod-experiments">multimethod-experiments</a> for details.</p>
<p>Runtimes for various dynamic method lookup algorithms:</p>
<ul>
  <li>
  <p><code>hashmaps</code> (faster-multimethods): Clojure 1.8.0 behavior except for ‘bug’ fixes. Replaces persistent hashmaps with Java hashmaps. (See <a href="changes.html">changes</a> for details.)</p></li>
  <li>
  <p><code>signatures</code>(faster-multimethods): uses specialized <code>Signature</code> dispatch values in place of persistent vectors.</p></li>
  <li>
  <p><code>nohierarchy</code>(faster-multimethods): optimizes for pure class-based dispatch.</p></li>
  <li>
  <p><code>defmulti</code>: Clojure 1.8.0</p></li>
  <li>
  <p><code>protocols</code>: Clojure 1.8.0 <code>defprotocol</code>, with hand-optimized if-then-else <code>instance?</code> calls to look up the correct method based on all arguments.</p></li>
  <li>
  <p><code>instanceof</code> hand optimized if-then-else Java method lookup;</p></li>
  <li>
  <p><code>instancefn</code> same as <code>instanceof</code> but implemented in Clojure and invoking Clojure functions rather than Java methods.</p></li>
  <li>
  <p><code>dynafun</code>: an experimental, incomplete library abandoning consistency with Clojure 1.8.0. No hierarchies; pure class-based method definition and lookup. For small arities, the current version does linear search in nested arrays, and avoids allocating and reclaiming dispatch values.</p></li>
</ul>
<img src="https://raw.githubusercontent.com/palisades-lakes/faster-multimethods/master/docs/figs/dynamic-multi.quantiles.png" alt="faster-multimethods vs Clojure 1.8.0 runtimes" style="width: 30cm" />
<p>Overhead, taking a hand optimized Java if-then-else <code>instanceof</code> algorithm as the baseline, as a fraction of the overhead of Clojure 1.8.0 <code>defmulti</code>:</p>
<img src="https://raw.githubusercontent.com/palisades-lakes/faster-multimethods/master/docs/figs/dynamic-multi-overhead.quantiles.png" alt="faster-multimethods overhead as a fraction of Clojure 1.8.0" style="width: 30cm" />
<p>Note that <a href="https://github.com/palisades-lakes/faster-multimethods">faster-multimethods</a> outperforms Clojure 1.8.0 protocols except in the case of repeated calls to a single method (the lowest curve in each plot). When restricted to pure class-based dispatch (<code>nohierarchy</code>), <a href="https://github.com/palisades-lakes/faster-multimethods">faster-multimethods</a> is close even in the single repeated method case, while being fully dynamic (unlike protocols, which are only dynamic for the first <code>this</code> argument).</p>
<p>I don’t understand why <code>protocols</code> so much worse than everything else for the <code>diameter</code> benchmark. That is a single argument multimethod (<code>this</code> only) and ought to be an easy case for protocols.</p>
<p>A caveat: These benchmarks are measured after a lot of warmup, giving HotSpot plenty of time to optimize what it can. Results might be very different in scenarios where the methods are not called as often.</p></div></div></div></body></html>
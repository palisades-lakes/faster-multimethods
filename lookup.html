<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>method lookup</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">faster-multimethods</span> <span class="project-version">0.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="overview.html"><div class="inner"><span>overview</span></div></a></li><li class="depth-1 "><a href="benchmarks.html"><div class="inner"><span>benchmarks</span></div></a></li><li class="depth-1  current"><a href="lookup.html"><div class="inner"><span>method lookup</span></div></a></li><li class="depth-1 "><a href="changes.html"><div class="inner"><span>change history</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="palisades.lakes.multimethods.core.html"><div class="inner"><span>palisades.lakes.multimethods.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#method-lookup" name="method-lookup"></a>method lookup</h1>
<p>A <em>multimethod</em> is a Clojure function (an instance of <code>palisades.lakes.multimethods.java.MultiFn</code> which implements <code>clojure.lang.IFn</code>) which, when invoked:</p>
<ol>
  <li>
  <p>First applies a <em>dispatch function</em> to the arguments, returning a <em>dispatch value</em>.</p></li>
  <li>
  <p>Finds the <em>appplicable methods</em> from a table mapping dispatch values to functions.</p></li>
  <li>
  <p>Finds the minima of a preference partial ordering of the applicable methods.</p></li>
  <li>
  <p>If there is a unique minimal method, it applies that to the arguments. If there are no applicable methods, or more than one minimal method, an exception is thrown.</p></li>
</ol>
<p>The purpose of this document is to explain the process in more detail.</p>
<p>Note: I believe what I describe here is more complicated than necessary, due to a desire to remain (mostly) consistent with Clojure 1.8.0 behavior. I’ve changed certain aspects of the behavior that I believe are unintended bugs — see <a href="https://github.com/palisades-lakes/faster-multimethods/blob/master/docs/changes.md">changes</a> for a detailed discussion. of the differences.</p>
<h2><a href="#dispatch-function" name="dispatch-function"></a>dispatch function</h2>
<p>The dispatch function is responsible for returning <em>legal dispatch values</em>.</p>
<p><strong>Warning:</strong> Because we want method lookup to be fast, the current implementation (like Clojure 1.8.0) doesn’t validate dispatch values before method lookup. Instead, a possibly mysterious looking exception will be thrown some time later. You can use <code>palisades.lakes.multimethods\legal-dispatch-value?</code> in your dispatch function, permanently if you can afford the cost, or at least in unit tests, and during development or debugging.</p>
<h3><a href="#legal-dispatch-values" name="legal-dispatch-values"></a>legal dispatch values</h3>
<p>Legal dispatch values are one of (my terminology):</p>
<ul>
  <li>
    <p><em>atomic</em></p>
    <ul>
      <li>an instance of <code>Class</code>.</li>
      <li>a namespace-qualified instance of <code>Named</code> (a <code>Symbol</code> or <code>Keyword</code>).</li>
    </ul>
  </li>
  <li>
  <p><code>:default</code>: a special case of a non-namespace-qualified keyword, for consistency with Clojure 1.8.0. Used to define a default method which is called when there are no other applicable methods. Dispatch functions may return <code>:default</code> to short cut method lookup.</p></li>
  <li>
    <p><em>recursive</em> </p>
    <p>an instance of <code>clojure.lang.IPersistentVector</code> whose elements are legal dispatch values, either atomic or recursive.</p>
  </li>
  <li>
    <p><em>signature</em></p>
    <p>an instance of <code>palisades.lakes.multimethods.java.Signature</code>, effectively an immutable <code>list</code> of classes.</p>
    <p>Atomic and recursive dispatch values are supported by Clojure 1.8.0 multimethods. </p>
    <p>Signatures, which are not recursive, are added here to optimize the common special case of pure class-based method lookup for multiple arguments. The current version of signatures is not recursive, and only supports single arity method functions with simple arglists (no destructuring).</p>
    <p>(It may work to use a <code>Signature</code> as a leaf in a recursive dispatch value, but I haven’t tested it, don’t recommend it, and don’t plan to support it. However, I open to arguments for why it would be worth the trouble.)</p>
  </li>
</ul>
<h2><a href="#dispatch-value-ordering" name="dispatch-value-ordering"></a>dispatch value ordering</h2>
<h3><a href="#applicable-methods-isa-" name="applicable-methods-isa-"></a>applicable methods (isa&lt;=)</h3>
<p>Applicable methods are determined using a partial ordering of dispatch values I’m calling <code>isa&lt;=</code>. <code>isa&lt;=</code> depends in general on a <code>Var</code> pointing to a shared, mutable Clojure <a href="https://clojure.org/reference/multimethods">hierarchy</a>.</p>
<p>The premise is that any method of <code>f</code> defined for dispatch value <code>y</code> could be applied to arguments resulting in dispatch value <code>x</code>, as long as <code>(isa&lt;= f x y)</code>.</p>
<p>(<a href="https://palisades-lakes.github.io/faster-multimethods/palisades.lakes.multimethods.core.html">faster-multimethods</a> has a function of the same name, but that’s provided for unit tests/debugging and isn’t called during method lookup.)</p>
<ul>
  <li>
  <p><code>(isa&lt;= f s0 s1)</code> if <code>(.isAssignableFrom s1 s0)</code>, when <code>s0</code> and <code>s1</code> are classes or signatures.</p></li>
  <li>
  <p><code>(isa&lt;= f r0 r1)</code>, when <code>r0</code> and <code>r1</code> are recursive dispatch values, if <code>r0</code> and <code>r1</code> are the same shape, and <code>(isa&lt;= f a0 a1)</code> is true for every pair of corresponding atomic leaves of <code>r0</code> and <code>r1</code>.</p></li>
  <li>
    <p><code>(isa&lt;= f a0 a1)</code> if <code>(clojure.core\isa? (.hierarchy f) a0 a1)</code> when <code>a0</code> and <code>a1</code> are atomic.</p>
    <ul>
      <li>
      <p>When <code>a0</code> and <code>a1</code> are both classes, <code>isa?</code> ignores the hierarchy, and is just <code>(.isAssignableFrom a1 a0)</code>.</p></li>
      <li>
      <p>When <code>a0</code> is <code>Named</code> and <code>a1</code> is a <code>Class</code>, <code>isa?</code> returns false. </p></li>
      <li>
      <p>Otherwise, the hierarchy is used. A hierarchy is a directed acyclic graph created with calls to <code>clojure.core/derive</code>. Edges in this graph connect 2 <code>Named</code> or a <code>Class</code> and a <code>Named</code>. The <code>isa?</code> relation is the transitive closure of the child-parent edge relation, that is, the descendant-ancestor relation. </p></li>
    </ul>
    <p><strong>Note:</strong> that <code>(isa? hierarchy c n)</code> may be true for a <code>Class</code> <code>c</code> and a <code>Named</code> <code>n</code>, but not the other way around.</p>
  </li>
</ul>
<h3><a href="#preferred-methods-dominates-" name="preferred-methods-dominates-"></a>preferred methods (dominates&lt;)</h3>
<p>The <code>dominates&lt;</code> (pseudo-code) relation extends <code>isa&lt;=</code> with additional explicit child-parent pairs, created by calling <code>prefer-method</code>.</p>
<p>The explicit <code>prefer-method</code> child-parent pairs may have any two dispatch values for child and parent, <code>Class</code>, <code>Named</code>, or recursive.</p>
<p><code>(prefer-method d0 d1)</code> checks that <code>d1</code> is not already preferred to <code>d0</code>, but otherwise allows any pair of values, which might or might not be legal dispatch values,  might not be the same shapes, etc.</p>
<p><code>(prefer-method d0 d1)</code> is only called if there is some <code>d2</code> such that <code>(isa&lt;= d2 d0)</code> and <code>(isa&lt;= d2 d1)</code>, so edges relating illegal dispatch values, or dispatch values of differing shapes, will have no effect.</p>
<p>On the other hand, the lack of validation in <code>prefer-method</code> is likely to cause difficult-to-debug surprises later.</p>
<p><strong>Note:</strong> The ordering of recursive dispatch values can only be changed for individual multimethods, making it harder to ensure consistent behavior in related multimethods, but at least limiting the damage radius of ill-considered changes.</p>
<h3><a href="#default-dispatch-value" name="default-dispatch-value"></a>default dispatch value</h3>
<p>Finally, every multimethod has a special <em>default dispatch value</em> (defaulting to <code>:default</code>). A method defined for the <em>default dispatch value</em> will be called if there are no applicable methods.</p>
<h2><a href="#method-lookup" name="method-lookup"></a>method lookup</h2>
<p>Each multimethod contains a table mapping certain dispatch values to the <em>defined methods</em>, themselves Clojure functions. </p>
<p>The second step in calling a multimethod has 3 parts:</p>
<ol>
  <li>
    <p>determine which of the defined methods are <code>isa&lt;=</code> applicable to the arguments’ dispatch value.</p>
    <p>If there are no applicable methods, throw an exception.</p>
  </li>
  <li>
    <p>find the <code>dominates&lt;</code> minima (most preferred) among the applicable methods.</p>
    <p>If there is more than one minimal method, throw an exception.</p>
  </li>
  <li>
  <p>apply the chosen method to the arguments.</p></li>
</ol></div></div></div></body></html>
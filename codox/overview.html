<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>overview</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">faster-multimethods</span> <span class="project-version">0.0.7</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="overview.html"><div class="inner"><span>overview</span></div></a></li><li class="depth-1 "><a href="changes.html"><div class="inner"><span>change history</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="palisades.lakes.multimethods.core.html"><div class="inner"><span>palisades.lakes.multimethods.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#overview" name="overview"></a>overview</h1>
<p><a href="https://clojars.org/palisades-lakes/faster-multimethods"><img src="https://img.shields.io/clojars/v/palisades-lakes/faster-multimethods.svg" alt="Clojars Project" /></a></p>
<p>Alternative to the Clojure 1.8.0 implementation of generic functions (aka multimethods) via <code>defmulti</code>/<code>defmethod</code>/<code>MultiFn</code>.</p>
<p>Very roughly 1/10 the cost for method lookup of Clojure 1.8.0, and comparable in performance to using protocols, while being fully dynamic.</p>
<h2><a href="#benchmarks" name="benchmarks"></a>benchmarks</h2>
<p>See <a href="https://github.com/palisades-lakes/multimethod-experiments">multimethod-experiments</a> for details.</p>
<p>Runtimes for various dynamic method lookup algorithms:</p>
<ul>
  <li>
  <p><code>hashmaps</code> (faster-multimethods): Clojure 1.8.0 behavior except for ‘bug’ fixes. Replaces persistent hashmaps with Java hashmaps. (See <a href="changes.html">changes</a> for details.)</p></li>
  <li>
  <p><code>signatures</code>(faster-multimethods): uses specialized <code>Signature</code> dispatch values in place of persistent vectors.</p></li>
  <li>
  <p><code>nohierarchy</code>(faster-multimethods): optimizes for pure class-based dispatch.</p></li>
  <li>
  <p><code>defmulti</code>: Clojure 1.8.0</p></li>
  <li>
  <p><code>protocols</code>: Clojure 1.8.0 <code>defprotocol</code>, with hand-optimized if-then-else <code>instance?</code> calls to look up the correct method based on all arguments.</p></li>
  <li>
  <p><code>instanceof</code> hand optimized if-then-else Java method lookup;</p></li>
  <li>
  <p><code>instancefn</code> same as <code>instanceof</code> but implemented in Clojure and invoking Clojure functions rather than Java methods.</p></li>
  <li>
  <p><code>dynafun</code>: an experimental, incomplete library abandoning consistency with Clojure 1.8.0. No hierarchies; pure class-based method definition and lookup. For small arities, the current version does linear search in nested arrays, and avoids allocating and reclaiming dispatch values.</p></li>
</ul>
<img src="../figs/dynamic-multi.quantiles.png" alt="faster-multimethods vs Clojure 1.8.0 runtimes" style="width: 24cm" />
<p>Overhead, taking a hand optimized Java if-then-else <code>instanceof</code> algorithm as the baseline, as a fraction of the overhead of Clojure 1.8.0 <code>defmulti</code>:</p>
<img src="../figs/dynamic-multi-overhead.quantiles.png" alt="faster-multimethods overhead as a fraction of Clojure 1.8.0" style="width: 24cm" />
<p>Note that <a href="https://github.com/palisades-lakes/faster-multimethods">faster-multimethods</a> outperforms Clojure 1.8.0 protocols except in the case of repeated calls to a single method (the lowest curve in each plot). When restricted to pure class-based dispatch (<code>nohierarchy</code>), <a href="https://github.com/palisades-lakes/faster-multimethods">faster-multimethods</a> is close even in the single repeated method case, while being fully dynamic (unlike protocols, which are only dynamic for the first <code>this</code> argument).</p>
<p>I don’t understand why <code>protocols</code> so much worse than everything else for the <code>diameter</code> benchmark. That is a single argument multimethod (<code>this</code> only) and ought to be an easy case for protocols.</p>
<p>A caveat: These benchmarks are measured after a lot of warmup, giving HotSpot plenty of time to optimize what it can. Results might be very different in scenarios where the methods are not called as often.</p>
<h2><a href="#usage" name="usage"></a>Usage</h2>
<h3><a href="#dependency" name="dependency"></a>Dependency</h3>
<h4><a href="#maven-" name="maven-"></a>Maven:</h4>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;palisades-lakes&lt;/groupId&gt;
  &lt;artifactId&gt;faster-multimethods&lt;/artifactId&gt;
  &lt;version&gt;0.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4><a href="#leiningen-boot-" name="leiningen-boot-"></a>Leiningen/Boot:</h4>
<pre><code class="clojure">[palisades-lakes/faster-multimethods "0.1.0"]
</code></pre>
<h3><a href="#code-examples" name="code-examples"></a>Code examples</h3>
<h4><a href="#fastest-" name="fastest-"></a>Fastest:</h4>
<pre><code class="clojure">(require `[palisades.lakes.multimethods.core :as plm])

(plm/defmulti intersects?
  "Test for general set intersection."
  {}  
  (fn intersects?-dispatch [s0 s1] (plm/extract-signature s0 s1))
  :hierarchy false)
  
(plm/defmethod intersects? 
  (plm/signature IntegerInterval java.util.Set)
  [^IntegerInterval s0 ^java.util.Set s1]
  (.intersects s0 s1))
  
...
</code></pre>
<h4><a href="#most-general-" name="most-general-"></a>Most general:</h4>
<pre><code class="clojure">(require `[palisades.lakes.multimethods.core :as plm])

(plm/defmulti intersects?
  "Test for general set intersection."
  {}  
  (fn intersects?-dispatch [s0 s1] [(class s0) (class s1))))

(plm/defmethod intersects? 
  [IntegerInterval java.util.Set]
  [^IntegerInterval s0 ^java.util.Set s1]
  (some #(.contains s0 %) s1))
  
...
</code></pre>
<h2><a href="#acknowledgments" name="acknowledgments"></a>Acknowledgments</h2>
<h3><a href="#yourkit" name="yourkit"></a><img src="https://www.yourkit.com/images/yklogo.png" alt="Yourkit" /></h3>
<p>YourKit is kindly supporting open source projects with its full-featured Java Profiler.</p>
<p>YourKit, LLC is the creator of innovative and intelligent tools for profiling Java and .NET applications. Take a look at YourKit’s leading software products:</p>
<ul>
  <li><a href="http://www.yourkit.com/java/profiler/index.jsp">YourKit Java Profiler</a> and</li>
  <li><a href="http://www.yourkit.com/.net/profiler/index.jsp">YourKit .NET Profiler</a>.</li>
</ul></div></div></div></body></html>